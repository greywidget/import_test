{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<ul> <li>Basic Modules</li> <li>Packages</li> <li>PYTHONPATH</li> <li>Namespace Packages</li> </ul>"},{"location":"four/","title":"Namespace Packages","text":"<p>A namespace package is a composite of various portions (a set of files in a single directory), where each portion contributes a subpackage to the parent package. See The import system - Namespace Packages</p> <p>Thanks to Ajyssa Coghlan's Note re import traps for the following example:</p> <p>Consider the following structure: <pre><code>ex03_namespace_packages/\n\u251c\u2500\u2500 project1\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 example\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 foo.py\n\u2514\u2500\u2500 project2\n    \u2514\u2500\u2500 example\n        \u2514\u2500\u2500 bar.py\n</code></pre> <code>foo.py</code> and <code>bar.py</code> both look like this: <pre><code>print(\"Hello from \", __name__)\n</code></pre> Notice that: - There are no <code>__init__.py</code> files - <code>project1</code> and <code>project2</code> both have a subdirectory called <code>example</code></p> <p><code>example</code> here is a <code>Namespace Package</code>.</p>"},{"location":"four/#our-example-package-has-portions-from-multiple-locations","title":"Our <code>example</code> package has portions from multiple locations","text":"<p>Let's add <code>project1</code> and <code>project2</code> to <code>PYTHONPATH</code>: <pre><code>$env:PYTHONPATH = \"C:\\Users\\Craig\\python_projects\\import_test\\ex03_namespace_packages\\project1;C:\\Users\\Craig\\python_projects\\import_test\\ex03_namespace_packages\\project2\"\n</code></pre></p> <p>If we go into the REPL, we can see that these two directories are in <code>sys.path</code>: <pre><code>&gt;&gt;&gt; import sys\n&gt;&gt;&gt; for item in sys.path:\n...     print(item)\nC:\\Users\\Craig\\python_projects\\import_test\\ex03_namespace_packages\\project1\nC:\\Users\\Craig\\python_projects\\import_test\\ex03_namespace_packages\\project2\nC:\\Users\\Craig\\AppData\\Local\\Programs\\Python\\Python312\\python312.zip\nC:\\Users\\Craig\\AppData\\Local\\Programs\\Python\\Python312\\DLLs\nC:\\Users\\Craig\\AppData\\Local\\Programs\\Python\\Python312\\Lib\nC:\\Users\\Craig\\AppData\\Local\\Programs\\Python\\Python312\nC:\\Users\\Craig\\python_projects\\import_test\\.venv\nC:\\Users\\Craig\\python_projects\\import_test\\.venv\\Lib\\site-packages\n&gt;&gt;&gt;\n</code></pre></p> <p>Let's try importing our <code>example</code> Namespace Package - if we look at its  <code>__path__</code> attribute, we will see that it includes both our projects: <pre><code>import example\n&gt;&gt;&gt; for item in example.__path__:\n...     print(item)\nC:\\Users\\Craig\\python_projects\\import_test\\ex03_namespace_packages\\project1\\example\nC:\\Users\\Craig\\python_projects\\import_test\\ex03_namespace_packages\\project2\\example\n&gt;&gt;&gt;\n</code></pre></p>"},{"location":"four/#we-can-import-modules-from-any-of-the-locations","title":"We can import modules from any of the locations","text":"<p>So, our <code>example</code> (Namespace) package has portions coming from multiple locations. We can prove that it works by importing our two python modules: <pre><code>&gt;&gt;&gt; import example.foo\nHello from example.foo\n&gt;&gt;&gt; from example import bar\nHello from example.bar\n</code></pre></p>"},{"location":"four/#heres-the-rub","title":"Here's the Rub","text":"<p>If we add a <code>__init__.py</code> file to <code>example.py</code> in either of our projects, the Python interpreter will create a single directory package containing only modules from that directory, rather than finding all appropriately named subdirectories. Lets add one. Our structure now looks like this: <pre><code>ex03_namespace_packages/\n\u251c\u2500\u2500 project1\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 example\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 foo.py\n\u2514\u2500\u2500 project2\n    \u2514\u2500\u2500 example\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 bar.py\n</code></pre> We have not changed anything else, both projects are in <code>sys.path</code>. If we import now: <pre><code>&gt;&gt;&gt; from example import foo\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nImportError: cannot import name 'foo' from 'example' (C:\\Users\\Craig\\python_projects\\import_test\\ex03_namespace_packages\\project2\\example\\__init__.py)\n&gt;&gt;&gt; from example import bar\nHello from example.bar\n&gt;&gt;&gt;\n</code></pre> We can no longer access <code>foo.py</code> because adding <code>__init__.py</code> to <code>project2/example</code> has turned <code>example</code> into a single directory package e.g. a normal package.</p> <p>Most of the time, we only create normal packages and so it is a good practice to always create <code>__init__.py</code></p>"},{"location":"one/","title":"Just Modules","text":"<pre><code>project\n\u251c\u2500\u2500 colours.py\n\u251c\u2500\u2500 main.py\n\u2514\u2500\u2500 messages.py\n</code></pre>"},{"location":"one/#modules-we-would-like-to-import","title":"Modules we would like to import","text":"colours.py<pre><code>def rainbow():\n    return \"red orange yellow green blue indigo violet\".split()\n\ndef dull():\n    return \"beige brown taupe\".split()\n</code></pre> messages.py<pre><code>def message_one():\n    return \"I came from one\"\n\ndef message_two():\n    return \"A bird in the hand is worth two in the bush (apparently)\"\n</code></pre>"},{"location":"one/#our-main-program","title":"Our main program","text":"main.py<pre><code>import colours\nimport messages\n\nprint(colours.dull())\nprint(messages.message_two())\nprint(colours.rainbow())\n</code></pre> <p>and this runs fine: <pre><code>python main.py\n['beige', 'brown', 'taupe']\nA bird in the hand is worth two in the bush (apparently)\n['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n</code></pre></p>"},{"location":"one/#can-we-import-individual-functions","title":"Can we import individual functions?","text":"main.py<pre><code>from messages import message_one\n\nprint(message_one())\n</code></pre> <p>yep, that's fine: <pre><code>python main.py\nI came from one\n</code></pre></p>"},{"location":"one/#what-about-importing","title":"What about importing *?","text":"<p>This does work but it's not recommended. (Ruff complains about it in VsCode) main.py<pre><code>from messages import *\n\nprint(message_one())\nprint(message_two())\n</code></pre></p> <p>yep, that's fine: <pre><code>python main.py\nI came from one\nA bird in the hand is worth two in the bush (apparently)\n</code></pre></p>"},{"location":"one/#what-about-relative-imports","title":"What about relative imports","text":"<p>This doesn't appear to work: main.py<pre><code>from . import colours\n\nprint(colours.dull())\n</code></pre></p> <pre><code>python main.py\nTraceback (most recent call last):\n  File \"C:\\Users\\Craig\\python_projects\\import_test\\ex01_just_modules\\main.py\", line 1, in &lt;module&gt;\n    from . import colours\nImportError: attempted relative import with no known parent package\n</code></pre> <p>and similarly, the following is not valid: main.py<pre><code>from .colours import dull\n\nprint(dull())\n</code></pre></p> <pre><code>python main.py\nTraceback (most recent call last):\n  File \"C:\\Users\\Craig\\python_projects\\import_test\\ex01_just_modules\\main.py\", line 1, in &lt;module&gt;\n    from .colours import dull\nImportError: attempted relative import with no known parent package\n</code></pre> <p>You can actually import this way, but it involves a discussion about packages. See packages</p>"},{"location":"three/","title":"PYTHONPATH","text":"<p>Using the same code as the previous example:</p> <pre><code>my_project\n\u2514\u2500\u2500 my_package\n    \u251c\u2500\u2500 colours.py\n    \u251c\u2500\u2500 main.py\n    \u2514\u2500\u2500 messages.py\n</code></pre>"},{"location":"three/#the-code-as-before","title":"The code - as before","text":"colours.py<pre><code>def rainbow():\n    return \"red orange yellow green blue indigo violet\".split()\n\ndef dull():\n    return \"beige brown taupe\".split()\n</code></pre> messages.py<pre><code>def message_one():\n    return \"I came from one\"\n\ndef message_two():\n    return \"A bird in the hand is worth two in the bush (apparently)\"\n</code></pre> main.py<pre><code>from . import messages\nfrom .colours import rainbow\n\nprint(rainbow())\nprint(messages.message_two())\n</code></pre> <p>We can manipulate the environment variable <code>PYTHONPATH</code> to contain our  package parent directory so that running <code>python -m my_package.main</code> will work  regardless of the directory we are in (i.e. we don't have to be in the parent directory of our package)</p>"},{"location":"three/#windows-powershell","title":"Windows Powershell","text":"<ul> <li><code>$env:PYTHONPATH</code> to view the current value</li> <li><code>$env:PYTHONPATH = \"c:\\Users\\Craig\\python_projects\\import_test\\ex02_packages\\my_project\\\"</code> to set to my value for this example</li> <li><code>$env:PYTHONPATH = \"\"</code> to unset the environment variable</li> </ul> <p>Be careful with this</p> <p>Be cautious when setting <code>PYTHONPATH</code> because it can potentially override  or conflict with system-wide Python installations and other environments.</p>"},{"location":"two/","title":"Packages","text":"<p>Packaging seems to be a mixture of the straightforward and the bewildering:</p> <ul> <li>Namespacing seems to make sense</li> <li>Do you or don't you need <code>__init__.py</code>?</li> <li>Is an installed package different to just being in my package project directory?</li> </ul> <p>Lets look at the following simple project structure:</p> <pre><code>my_project\n\u2514\u2500\u2500 my_package\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 colours.py\n    \u251c\u2500\u2500 main.py\n    \u2514\u2500\u2500 messages.py\n</code></pre> <p>Notice there IS a <code>__init__.py</code> file in the <code>my_package</code> directory </p> <p>Although it might not be necessary to have a <code>__init__.py</code> file, it is  usually best to have one. You should only omit it if you are creating a  Namespace Package</p>"},{"location":"two/#the-utility-modules-are-the-same-as-before","title":"The utility modules are the same as before","text":"colours.py<pre><code>def rainbow():\n    return \"red orange yellow green blue indigo violet\".split()\n\ndef dull():\n    return \"beige brown taupe\".split()\n</code></pre> messages.py<pre><code>def message_one():\n    return \"I came from one\"\n\ndef message_two():\n    return \"A bird in the hand is worth two in the bush (apparently)\"\n</code></pre>"},{"location":"two/#but-our-main-program-is-doing-some-relative-imports","title":"But our main program is doing some relative imports","text":"main.py<pre><code>from . import messages\nfrom .colours import rainbow\n\nprint(rainbow())\nprint(messages.message_two())\n</code></pre>"},{"location":"two/#the-relative-import-error-again","title":"The relative import error again","text":"<p>If we navigate to <code>my_package</code> where the modules are, and try running <code>main.py</code> we get the error we saw earlier:</p> <pre><code>python main.py\nTraceback (most recent call last):\n  File \"C:\\Users\\Craig\\python_projects\\import_test\\ex02_packages\\my_project\\my_package\\main.py\", line 1, in &lt;module&gt;\n    from . import messages\nImportError: attempted relative import with no known parent package\n</code></pre> <p>The same thing happens if we try to import <code>main</code> when we are in that directory: <pre><code>&gt;&gt;&gt; import main\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"C:\\Users\\Craig\\python_projects\\import_test\\ex02_packages\\my_project\\my_package\\main.py\", line 1, in &lt;module&gt;\n    from . import messages\nImportError: attempted relative import with no known parent package\n</code></pre></p>"},{"location":"two/#lets-try-again-from-the-parent-directory","title":"Let's try again from the parent directory:","text":"<p>If we navigate to the parent directory <code>my_project</code> and try the import again: <pre><code>&gt;&gt;&gt; import main\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nModuleNotFoundError: No module named 'main'\n</code></pre></p>"},{"location":"two/#our-module-is-now-in-a-child-directory","title":"Our module is now in a child directory","text":"<p>Of course that didn't work - <code>main.py</code> is inside our <code>my_package</code> directory. Let's try again: <pre><code>&gt;&gt;&gt; from my_package import main\n['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\nA bird in the hand is worth two in the bush (apparently)\n</code></pre> This time our import works. We could also import like this: <pre><code>&gt;&gt;&gt; import my_package.main\n['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\nA bird in the hand is worth two in the bush (apparently)\n</code></pre></p>"},{"location":"two/#so-whats-the-deal-with-the-parent-directory-thing","title":"So, what's the deal with the parent directory thing?","text":"<p>Running your code from the top-level directory works because it provides Python with a clear reference point for package structure. When you execute a script from the top-level directory of your project, Python considers that directory as the starting point for resolving package imports.</p>"},{"location":"two/#but-what-about-running-it-rather-than-importing-it","title":"But what about running it rather than importing it","text":"<p><pre><code>python my_package\\main.py\nTraceback (most recent call last):\n  File \"C:\\Users\\Craig\\python_projects\\import_test\\ex02_packages\\my_project\\my_package\\main.py\", line 1, in &lt;module&gt;\n    from . import messages\nImportError: attempted relative import with no known parent package\n</code></pre> No joy there, but actually we can run it like this:</p>"},{"location":"two/#using-python-m","title":"Using <code>python -m</code>","text":"<pre><code>python -m my_package.main\n['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\nA bird in the hand is worth two in the bush (apparently)\n</code></pre>"},{"location":"two/#module-execution-vs-script-execution","title":"Module execution vs Script execution","text":"<ul> <li>When you run <code>python package1\\module1.py</code>, you're directly executing the script file module1.py as if it were a standalone script. Python treats it as a script execution, and the script file is executed in its own namespace.</li> <li>When you run <code>python -m package1.module1</code>, you're telling Python to run the module module1 as if it were a part of a package. Python treats it as a module execution, and the module is executed in the context of its package.</li> </ul>"},{"location":"two/#python-path-handling","title":"Python path handling","text":"<ul> <li>When you run <code>python package1\\module1.py</code>, Python adds the directory containing <code>module1.py</code> to the beginning of <code>sys.path</code>. This means that the directory containing <code>module1.py</code> becomes the first place where Python looks for modules when resolving imports.</li> <li>When you run <code>python -m package1.module1</code>, Python doesn't modify <code>sys.path</code>. Instead, it looks for the module module1 within the package package1, starting from the current directory.</li> </ul>"},{"location":"two/#relative-imports-behaviour","title":"Relative imports behaviour","text":"<ul> <li>When you run <code>python package1\\module1.py</code>, relative imports within <code>module1.py</code> are resolved based on the directory containing <code>module1.py</code>.</li> <li>When you run <code>python -m package1.module1</code>, relative imports within <code>module1.py</code> are resolved based on the package structure. The top-level package (package1 in this case) is considered the starting point for relative imports.</li> </ul>"}]}